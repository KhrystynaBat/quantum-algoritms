"""
Алгоритм Гровера

Цей модуль реалізує алгоритм Гровера для пошуку в неупорядкованій базі даних.

Основні функції:
- needle_random(max): Генерує випадковий вхідний рядок на основі випадкового числа.
- needle_explicit(): Явно задає вхідний рядок.
- needle_binary(): Генерує вхідний рядок на основі бінарної позиції.
- needle_decimal(): Генерує вхідний рядок на основі десяткової позиції.

Залежності: qutip, numpy
"""

import math

import matplotlib.pyplot as plt
import numpy as _np
from numpy import *
from qutip import basis, tensor, sigmax, qeye, Qobj


# Надаємо явні посилання на функції, що використовуються з qutip.qip.operations,
# щоб уникнути проблем зі статичним аналізом. Визначаємо локальні реалізації безумовно,
# щоб модуль був самодостатнім для статичного аналізу та простого виконання.
def hadamard_transform(n):
    """
    Генерує матрицю Адамара для одного кубіта.

    Параметри:
        n (int): Розмір матриці (завжди 1).

    Повертає:
        Qobj: Матриця Адамара.
    """
    # У цих скриптах використовується лише n==1
    h = (1.0 / _np.sqrt(2.0)) * _np.array([[1, 1], [1, -1]])
    return Qobj(h)


def cnot():
    """
    Генерує матрицю CNOT.

    Повертає:
        Qobj: Матриця CNOT.
    """
    return Qobj(_np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]))


#############################################################################
# Частина Перша: Генеруємо input_string та викликаємо needle_init()
#############################################################################

# У Частині Першій ми генеруємо <input_string>, який повністю складається з 0,
# за винятком однієї 1, що представляє елемент, який ми шукаємо в рядку.
# Довжина <input_string> має бути степенем двійки, що важливо для
# needle_explicit(); рядок завжди можна доповнити додатковими 0, якщо необхідно.

# Метод 1. Випадкова генерація. Викликати needle_random()
# Метод 2. Явне присвоєння. Викликати needle_explicit()
# Метод 3. Позиція в бінарному вигляді. Викликати needle_binary()
# Метод 4. Позиція в десятковому вигляді. Викликати needle_decimal()

# -----------------------------------------------------------------------------
# Функція: needle_random(max)
# -----------------------------------------------------------------------------
# Генерує input_string випадковим чином, на основі випадкового цілого числа.
# -----------------------------------------------------------------------------
# max: верхня межа для випадкового цілого числа, як степінь двійки.
# -----------------------------------------------------------------------------
def needle_random(max=5):
    """
    Генерує випадковий вхідний рядок на основі випадкового числа.

    Параметри:
        max (int): Верхня межа для випадкового числа, як степінь двійки.

    Повертає:
        str: Випадково згенерований бінарний рядок.
    """
    # Генерує випадковий вхідний рядок довжини 2**k з однією "1" у випадковій позиції.
    #
    # Параметри:
    # - max (int): максимальна ступінь 2**max для довжини рядка (min length = 2)
    #
    # Повертає:
    # - input_string (str)
    random_length = 2 ** random.randint(1, max)
    random_input_string = '0' * random_length
    random_needle = random.randint(0, random_length - 1)
    random_input_string = (random_input_string[:random_needle] + '1' + random_input_string[random_needle + 1:])
    input_string = random_input_string
    return input_string


# -----------------------------------------------------------------------------
# Функція: needle_explicit(input_string)
# -----------------------------------------------------------------------------
# Генерує input_string на основі явно заданого рядка.
# Пам'ятайте, що довжина рядка має бути степенем двійки.
# -----------------------------------------------------------------------------
# input_string: рядок для повернення
# -----------------------------------------------------------------------------
def needle_explicit(input_string='0010' + ('0' * 60)):
    """
    Повертає явно заданий вхідний рядок (довжина повинна бути степенем двійки).

    Параметри:
        input_string (str): Вхідний рядок.

    Повертає:
        str: Явно заданий рядок.
    """
    # Повертає явно заданий вхідний рядок (повинен мати довжину степінь двійки).
    #
    # Використовуйте для відлагодження/експериментів з фіксованою голкою.
    return input_string


# -----------------------------------------------------------------------------
# Функція: needle_binary(binary_needle_position)
# -----------------------------------------------------------------------------
# Генерує input_string на основі бінарної позиції.
# -----------------------------------------------------------------------------
# binary_needle_position: позиція у бінарному вигляді
# -----------------------------------------------------------------------------
def needle_binary(binary_needle_position='0100'):
    # Створює вхідний рядок на основі бінарного представлення позиції голки.
    #
    # Параметри:
    # - binary_needle_position (str): позиція голки в бінарному вигляді.
    decimal_needle_position = int(binary_needle_position, 2)
    input_string_length = 2 ** math.ceil(math.log(decimal_needle_position + 1, 2))
    input_string = '0' * decimal_needle_position
    input_string = input_string + '1'
    input_string = input_string + '0' * (input_string_length - decimal_needle_position - 1)
    return input_string


# -----------------------------------------------------------------------------
# Функція: needle_decimal()
# -----------------------------------------------------------------------------
# Генерує input_string на основі десяткової позиції.
# -----------------------------------------------------------------------------
# decimal_needle_position: позиція у десятковому вигляді
# -----------------------------------------------------------------------------
def needle_decimal(decimal_needle_position=5):
    # Створює вхідний рядок на основі десяткового індексу голки.
    #
    # Параметри:
    # - decimal_needle_position (int): позиція голки у десятковому вигляді.
    input_string_length = 2 ** math.ceil(math.log(decimal_needle_position + 1, 2))
    input_string = '0' * decimal_needle_position
    input_string = input_string + '1'
    input_string = input_string + '0' * (input_string_length - decimal_needle_position - 1)
    return input_string


# -----------------------------------------------------------------------------
# Функція: needle_init()
# -----------------------------------------------------------------------------
# Ініціалізує позицію голки на основі input_string
# -----------------------------------------------------------------------------
def needle_init(input_string):
    # Аналізує вхідний рядок та повертає метадані про рядок і голку.
    #
    # Параметри:
    # - input_string (str)
    #
    # Повертає:
    # - tuple: (input_info_dict, needle_info_dict)
    #
    # Маючи <input_string>, отримуємо довжину та обчислюємо необхідну кількість
    # кубітів для обробки рядка.
    input_string_length = input_string.__len__()
    required_qubits = int(math.log(input_string_length, 2))

    # Отримуємо позицію голки. Ми будемо використовувати це для генерації вентилів та відображення
    # різних результатів.
    needle_position = input_string.find('1')
    needle_binary = binary_repr(needle_position, required_qubits)
    needle_binary_length = needle_binary.__len__()

    return ({'string': input_string, 'string_length': input_string_length, 'required_qubits': required_qubits},
            {'position': needle_position, 'binary': needle_binary, 'binary_length': needle_binary_length})


##############################################################################
# Частина Друга: Налаштування Кубітів та Вентилів
##############################################################################

# У Частині Другій ми налаштовуємо всі елементи, необхідні для виконання
# квантової схеми Алгоритму Гровера. Викликайте circuit() для налаштування
# наступного:
#
# qubits - Масив усіх кубітів (включаючи контрольний)
# Q      - Кубіти в об'єднаному стані
# H      - Вентилі Адамара для всіх кубітів
# UfXI   - Інверсія фази з I на контрольному кубіті
# CxNOT  - Керуємий NOT на всіх вентилях
# HxI    - Вентилі Адамара для всіх, крім I на контрольному кубіті
# XxI    - Вентилі X для всіх, крім I на контрольному кубіті
# CxZI   - Керуємий Z на всіх вентилях з I на контрольному кубіті
# IxH    - H на контрольному кубіті
# IxX    - X на контрольному кубіті
#
# Uf     - Створено за допомогою UfXI та CxNOT
# Dif    - Створено за допомогою HxI, Xx, та CxZI

# Як останній крок у Частині Другій, ми обчислюємо значення для repeat, яке
# визначає, скільки разів схема циклічно повторюється, щоб максимізувати
# шанс ідентифікації позиції голки.

# -----------------------------------------------------------------------------
# Функція: circuit()
# -----------------------------------------------------------------------------
# Ініціалізує елементи схеми (кубіти та вентилі)
#
# Примітка щодо угод про іменування змінних для матриць: велика літера - це
# колекція однорідних елементів. Отже, 'Q' означає кубіти на всьому шляху,
# а 'H' означає Адамари на всьому шляху. Маленька 'x' - це жадібний підстановочний
# символ, тому 'HxI' означає Адамари на всьому шляху, крім Одиничного вентиля внизу.
# 'CxNOT' означає керування (C) на всьому шляху, крім NOT внизу.
# -----------------------------------------------------------------------------
def circuit(input, needle):
    # Будує початковий стан і оператори, необхідні для виконання схеми Гровера.
    #
    # Параметри:
    # - input (dict): словник з інформацією про рядок (string, string_length, required_qubits)
    # - needle (dict): словник з інформацією про голку (position, binary, binary_length)
    #
    # Повертає:
    # - dict: оператори та початковий стан {'Q','H','Uf','Dif','IxH','IxX'}

    # ------
    # qubits (кубіти)
    # ------
    #
    # Створюємо масив кубітів. Вхідний рядок довжини $2^n$ вимагає $n$ кубітів,
    # що починаються в стані $|0\rangle$, плюс один контрольний кубіт, що починається в стані $|1\rangle$.
    qubits = []
    for i in range(input['required_qubits']):
        qubits.append(basis(2, 0))  # 0 кубіт
    qubits.append(basis(2, 1))  # 1 кубіт (контрольний)

    # ------
    # Q (об'єднаний стан)
    # ------
    #
    # Усі кубіти об'єднуються у спільний стан за допомогою тензорного добутку
    Q = None
    for qubit in qubits:
        if Q:
            Q = tensor(Q, qubit)
        else:
            Q = tensor(qubit)

    # ------
    # H (Адамари)
    # ------
    #
    # Адамари як комбінована операція для всіх кубітів
    H = None
    for qubit in qubits:
        if H:
            H = tensor(H, hadamard_transform(1))
        else:
            H = hadamard_transform(1)

    # ------
    # Uf (Оракул)
    # ------
    # Існує два різні методи для генерації Uf:
    #
    # Метод 1: Побудова Uf з більш примітивних квантових вентилів. Викликати uf1().
    # Метод 2: Прямий опис матриці для Uf. Викликати uf2().
    #
    # Ми включаємо обидва методи, оскільки кожен дає певне розуміння.

    # -----------------------------------------------------------------------------
    # Функція: uf1()
    # -----------------------------------------------------------------------------
    # Метод 1 для генерації вентиля Uf (= інверсія фази)
    # -----------------------------------------------------------------------------
    def uf1():

        # Uf можна створити кількома способами. Перший - розбити Uf наступним
        # чином: (i) комбінований стан, що представляє елемент, який ми шукаємо, у
        # бінарному вигляді, (ii) керуємий NOT, де всі кубіти є керуючими, крім
        # останнього, який є NOT; (iii) той самий комбінований стан, що й (i).
        #
        # |> -----.-----
        # |> -- X . X --
        # |> ---- + ----
        #
        # Ми робимо це, створюючи UfXI, що відповідає (i) та (iii), та CxNOT,
        # що відповідає (ii). Потім ми можемо об'єднати (UfXI * CxNOT * UfXI), щоб
        # отримати Uf.

        # Обчислюємо бінарне значення, яке відповідає позиції елемента, який
        # потрібно знайти (який ми називаємо голкою). Потім проходимо по цьому
        # бінарному числу: кожна 0 буде відповідати вентилю X; кожна 1 буде
        # відповідати вентилю I. Отже, якщо третій (з чотирьох елементів) є голкою,
        # це дає нам 010, що відповідає [X I X]. Завершуємо UfXI, включивши
        # одиничний вентиль для контрольного кубіта.
        #
        # Необхідні вентилі: UfXI, CxNOT

        UfXI = None
        for i in range(needle['binary_length']):
            if needle['binary'][i] == '0':
                if UfXI:
                    UfXI = tensor(UfXI, sigmax())
                else:
                    UfXI = sigmax()
            else:
                if UfXI:
                    UfXI = tensor(UfXI, qeye(2))
                else:
                    UfXI = qeye(2)
        # Додаємо Одиничний вентиль для контрольного кубіта
        UfXI = tensor(UfXI, qeye(2))

        # CxNOT як комбінована операція. Вона обчислюється як серія одиничних
        # вентилів, з вентилем NOT у нижньому правому куті.
        CxNOT = zeros([input['string_length'] * 2, input['string_length'] * 2])
        for i in range(input['string_length'] - 1):
            CxNOT[i * 2, i * 2] = 1
            CxNOT[i * 2 + 1, i * 2 + 1] = 1
        CxNOT[input['string_length'] * 2 - 1, input['string_length'] * 2 - 2] = 1
        CxNOT[input['string_length'] * 2 - 2, input['string_length'] * 2 - 1] = 1

        # Перетворюємо CxNOT на Qobj та встановлюємо розміри (dims), щоб вони
        # відповідали UfXI для коректного множення
        CxNOT = Qobj(CxNOT)
        try:
            CxNOT.dims = UfXI.dims
        except Exception:
            pass

        # Обчислюємо Uf
        Uf = UfXI * CxNOT * UfXI
        return Uf

    # -----------------------------------------------------------------------------
    # Функція: uf2()
    # -----------------------------------------------------------------------------
    # Метод 2 для генерації вентиля Uf (= інверсія фази)
    # -----------------------------------------------------------------------------
    def uf2():

        # Інший спосіб створити Uf - зробити це безпосередньо, згенерувавши нульову
        # матрицю розміру $2^n \times 2^n$ і розміщуючи 1 там, де це необхідно,
        # відповідно до наступного алгоритму:
        Uf = zeros([input['string_length'] * 2, input['string_length'] * 2])
        for i in range(input['string_length']):
            if input['string'][i] == '0':
                Uf[i * 2, i * 2] = 1
                Uf[i * 2 + 1, i * 2 + 1] = 1
            else:
                Uf[i * 2 + 1, i * 2] = 1
                Uf[i * 2, i * 2 + 1] = 1
        return Qobj(Uf)

    # Встановлюємо Uf, використовуючи uf1() або uf2() (обидва еквівалентні)
    Uf = uf1()

    # ------
    # Dif (Дифузійний оператор)
    # ------
    # Існує два різні методи для генерації Dif; ці методи паралельні тому,
    # як ми генерували Uf.
    #
    # Метод 1: Побудова Dif з більш примітивних квантових вентилів. Викликати dif1().
    # Метод 2: Прямий опис матриці для Dif. Викликати dif2().
    #
    # Знову ж таки, ми включаємо обидва методи, оскільки кожен дає певне розуміння.

    # -----------------------------------------------------------------------------
    # Функція: dif1()
    # -----------------------------------------------------------------------------
    # Метод 1 для вентиля Dif (= інверсія відносно середнього)
    # -----------------------------------------------------------------------------
    def dif1():

        # Генеруємо дифузійний оператор Dif. Цей оператор залишає контрольний
        # кубіт недоторканим, але для інших кубітів слідує наступному шаблону:
        #
        # |> -- H X . X H --
        # |> -- H X Z X H --
        #
        # Щоб згенерувати цей оператор, нам потрібно об'єднати Адамари для
        # кожного неконтрольного кубіта та Одиничний вентиль для контрольного;
        # та X для кожного неконтрольного кубіта та Одиничний вентиль для
        # контрольного. Нарешті, ми повинні мати керуємий Z для неконтрольного
        # кубіта та Одиничний вентиль для контрольного. (Цей оператор не діє
        # безпосередньо на контрольний кубіт.)
        #
        # Необхідні вентилі: HxI, XxI, CxZI

        # Адамари + Одиничний вентиль (для контрольного кубіта) як комбінована операція
        HxI = None
        for qubit in qubits[:-1]:
            if HxI:
                HxI = tensor(HxI, hadamard_transform(1))
            else:
                HxI = hadamard_transform(1)
        HxI = tensor(HxI, qeye(2))

        # X + Одиничний вентиль (для контрольного кубіта) як комбінована операція
        XxI = None
        for qubit in qubits[:-1]:
            if XxI:
                XxI = tensor(XxI, sigmax())
            else:
                XxI = sigmax()
        XxI = tensor(XxI, qeye(2))

        # CxZ + Одиничний вентиль (для контрольного кубіта) як комбінована операція
        CxZI = zeros([input['string_length'], input['string_length']])
        for i in range(int(input['string_length'] - 1)):
            CxZI[i, i] = 1
        CxZI[input['string_length'] - 1, input['string_length'] - 1] = -1
        CxZI = tensor(Qobj(CxZI), qeye(2))
        CxZI.dims = HxI.dims

        # Дифузійний оператор
        Dif = HxI * XxI * CxZI * XxI * HxI
        return Dif

    # -----------------------------------------------------------------------------
    # Функція: dif2()
    # -----------------------------------------------------------------------------
    # Метод 2 для вентиля Dif (= інверсія відносно середнього)
    # -----------------------------------------------------------------------------
    def dif2():

        # Інший спосіб згенерувати Dif - обчислити -I+2A, де A - це матриця,
        # яка знаходить середню послідовність ($1/2^n$, де $n$ - кількість кубітів
        # входу) і I - одинична матриця. Отримана матриця об'єднується з
        # одиничною матрицею (оскільки вона не діє безпосередньо на контрольний кубіт).

        A = (1 / (2 ** input['required_qubits'])) * ones([2 ** input['required_qubits'], 2 ** input['required_qubits']])
        Two_A = 2 * A
        Minus_I = -1 * identity(2 ** input['required_qubits'])
        Dif = tensor(Qobj(Minus_I + Two_A), qeye(2))
        return Dif

    # Встановлюємо Dif, використовуючи dif1() або dif2() (обидва еквівалентні)
    Dif = dif1()

    # Остання пара операцій діє на контрольний кубіт, і це посилює результати,
    # роблячи їх більш виразними. Створюємо дві комбіновані операції, які діють
    # лише на контрольний кубіт (тому решта буде I): IxH та IxX.
    #
    # Необхідні вентилі: IxH, IxX

    # ------
    # IxH
    # ------
    # Ix + Адамар (для контрольного кубіта) як комбінована операція
    IxH = None
    for qubit in qubits[:-1]:
        if IxH:
            IxH = tensor(IxH, qeye(2))
        else:
            IxH = qeye(2)
    IxH = tensor(IxH, hadamard_transform(1))

    # ------
    # IxX
    # ------
    # Ix + X (для контрольного кубіта) як комбінована операція
    IxX = None
    for qubit in qubits[:-1]:
        if IxX:
            IxX = tensor(IxX, qeye(2))
        else:
            IxX = qeye(2)
    IxX = tensor(IxX, sigmax())

    # Повертаємо словник кубітів та вентилів
    return {'Q': Q, 'H': H, 'Uf': Uf, 'Dif': Dif, 'IxH': IxH, 'IxX': IxX}


# -----------------------------------------------------------------------------
# Функція: repeat(required_qubits)
# -----------------------------------------------------------------------------
# Інверсія фази (Uf) + Дифузійний оператор (Dif) повторюються $\pi/4 \cdot \sqrt{2^n}$ разів,
# де $n$ - це кількість кубітів (не включаючи контрольний). Це виділяє,
# а потім підсилює результат, щоб відповідь було легко побачити. Якщо повторити
# це більше разів, ніж потрібно, числа стануть "пересмаженими" (тобто ми
# відійдемо від ідеального рішення).
# -----------------------------------------------------------------------------
# required_qubits: кількість циклів залежить від кількості кубітів у схемі
# -----------------------------------------------------------------------------
def repeat(required_qubits):
    # Обчислює рекомендувану кількість ітерацій Grover-ітерації для n кубітів.
    #
    # Параметри:
    # - required_qubits (int)
    #
    # Повертає:
    # - int: число повторень
    #
    # Ми можемо подумати, що int(around((pi/4) * sqrt(2**input['required_qubits'])))
    # було б краще. Але це призводить до того, що схеми з 2 кубітами (+1 контрольний)
    # запускаються двічі замість одного разу, що "пересмажує" результати.
    return int((pi / 4) * sqrt(2 ** (required_qubits)))


##############################################################################
# Частина Третя: Виконання схеми
##############################################################################

# Щоб запустити схему, ми застосовуємо вентилі до кубітів у їхніх
# об'єднаних станах. Це просто множення матриць. Починаємо із застосування
# H до кожного кубіта; потім Uf (інверсія фази); потім Dif (інверсія відносно
# середнього); потім завершуємо застосуванням H та X до контрольного кубіта.

# -----------------------------------------------------------------------------
# Функція: run_circuit(circuit, repeat)
# -----------------------------------------------------------------------------
# Виконує обчислення схеми. Повторює Uf/Dif відповідну кількість разів.
# -----------------------------------------------------------------------------
# circuit: словник для схеми (очікується: Q, H, Uf, Dif, IxH, IxX)
# repeat: ціле число, що представляє кількість повторень Uf/Dif
# -----------------------------------------------------------------------------
def run_circuit(circuit, repeat):
    # Виконує послідовність операторів схеми і повертає кінцевий стан (Qobj).
    #
    # Параметри:
    # - circuit (dict): результат функції circuit(...)
    # - repeat (int): число повторень операції Uf*Dif
    #
    # Повертає:
    # - Qobj: вектор стану після виконання схеми

    # Починаємо із застосування H до Q
    current_state = circuit['H'] * circuit['Q']

    # Тепер повторюємо Uf та Dif <repeat> разів. Це ітерація Гровера.
    for i in range(repeat):
        current_state = circuit['Uf'] * current_state
        current_state = circuit['Dif'] * current_state
        current_state = Qobj(current_state)

    # Тепер застосовуємо IxH та IxX.
    current_state = circuit['IxX'] * circuit['IxH'] * current_state
    return current_state


##############################################################################
# Частина Четверта: Результати та Інтерпретація
##############################################################################

# -----------------------------------------------------------------------------
# Функція: results(input, needle, repeat, current_state)
# -----------------------------------------------------------------------------
# Виводить результати на консоль.
# -----------------------------------------------------------------------------
# input: словник, що містить string, string_length, required_qubits
# needle: словник, що містить position, binary, binary length
# repeat: ціле число, що представляє кількість повторень Uf/Dif
# current_state: результати після виконання схеми
# -----------------------------------------------------------------------------
def results(input, needle, repeat, current_state):
    # Інтерпретує і друкує результати виконання алгоритму Гровера.
    #
    # Параметри:
    # - input (dict): інформація про вхідний рядок
    # - needle (dict): інформація про голку
    # - repeat (int): кількість ітерацій
    # - current_state (Qobj): стан після виконання схеми

    # Переконуємося, що ми працюємо з масивом numpy для індексації
    arr = current_state.full().flatten()

    max_state = int(argmax(abs(arr)))
    max_state_value = abs(arr[max_state])
    min_state = int(argmin(abs(arr)))
    min_state_value = abs(arr[min_state])

    if max_state_value > min_state_value:
        result_index = max_state
        result_value = max_state_value
    else:
        result_index = min_state
        result_value = min_state_value
    # Індекс результату потрібно розділити на 2, оскільки контрольний кубіт подвоює простір станів
    result = int(result_index / 2)

    print('-' * 60)
    print('Об\'єднаний стан (Combined state):')
    for i in range(arr.size):
        if i == result * 2:
            flag = '*****'
        else:
            flag = ''
        print(binary_repr(i, input['required_qubits'] + 1), ':', arr[i], flag)

    print('-' * 60)
    print('Вхідний рядок (Input string)             :', input['string'])
    print('Фактична Позиція (Actual Position) (десяткова):', needle['position'])
    print('Фактична Позиція (Actual Postiion) (бінарна) :', needle['binary'])
    print('Необхідна кількість ітерацій (Iterations required)      :', repeat)
    print('Необхідна кількість кубітів (Qubits required)          :', input['required_qubits'], '(+1 контрольний)')

    print('Стан виграшного кубіта (State of winning qubit)   :', arr[max_state])

    check = input['string'].find('1')
    if result == check:
        confirmed = '(підтверджено)'
    else:
        confirmed = '(помилка)'

    print('Обчислена позиція (Calculated position)      : {} {}'.format(result, confirmed))
    print('-' * 60)


def visualize_results(current_state, input_length):
    """
    Візуалізує ймовірності квантових станів після виконання алгоритму Гровера.

    Параметри:
        current_state (Qobj): Вектор стану після виконання схеми.
        input_length (int): Довжина вхідного рядка.
    """
    probabilities = abs(current_state.full().flatten()) ** 2
    # Обчислюємо кількість неконтрольних кубітів
    num_qubits = int(math.log(input_length, 2))
    # Формуємо мітки станів. Увага: тут використовуються лише n біт для мітки,
    # хоча загальна кількість станів 2^(n+1).
    states = [f"|{bin(i)[2:].zfill(num_qubits)}|" for i in range(len(probabilities))]

    plt.bar(states, probabilities, color='purple', alpha=0.7)
    plt.xlabel("Квантові стани")
    plt.ylabel("Ймовірності")
    plt.title("Ймовірності квантових станів (алгоритм Гровера)")
    plt.xticks(rotation=90)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()


if __name__ == '__main__':
    """
    Виконує алгоритм Гровера та виводить результати.
    """
    ##############################################################################
    # Запуск Алгоритму Гровера та інтерпретація результатів
    ##############################################################################
    # Частина Перша: Генеруємо <input_string> та викликаємо needle_init()
    input_string = needle_random()
    input, needle = needle_init(input_string)

    # Частина Друга: Налаштування Кубітів та Вентилів
    circuit = circuit(input, needle)
    repeat = repeat(input['required_qubits'])

    # Частина Третя: Виконання схеми
    current_state = run_circuit(circuit, repeat)

    # Частина Четверта: Результати та Інтерпретація
    results(input, needle, repeat, current_state)

    # Візуалізація результатів
    visualize_results(current_state, len(input['string']))